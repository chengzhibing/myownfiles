### 什么是设计模式
针对设计问题的通用解决方案。
### 为什么学习设计模式
1、有利于代码复用。
2、有利于代码稳定可拓展
3、有利于代码可读性的提升
### 什么时候需要用到设计模式
### 五大设计原则
1、开闭原则：对于系统的拓展开放，对于修改关闭。
2、单一职责原则：解耦让每个模块更加的独立，一个功能模块只干一件事。
3、依赖倒置原则：上层不应该依赖下层的实现，系统依赖于接口的实现而不依赖于具体的实现。
4、接口隔离原则
5、里氏置换原则。
### 模式的分类：
1、创建型：（创建元素）
（1）工厂模式：生产同类型产品
（2）建造者模式：拆分简单模块，独立执行==>注重过程与搭配。//一句话：每个模块独立解耦，而建造者负责创建串联正题系统
（3）单例模式：整个系统只需要一个全局的实例：Vu-router, Store
//====模式场景
//批量生产同类型的应用来满足频繁使用同一种类型的需求时--工厂模式
//当我们需要模块，拆分一个大的模块，同时是模块间独立解耦分工--建造着模式
//全局只需要一个实例，注重统一一体化---单例


//例：生产不同类型的按钮，==>生产多个本质相同，利用传参区分不同属的元素====》工厂模式
//例：全局应用：router, store ==》只需要一个实例==>单例
//例：页头组件Header，包含了title,button,breadcum==>生产多种不同类型的元素==>建造者模式
2、结构型：
（1）适配器模式：新输入的功能兼容旧的功能点，适配已有的方案。
（2）装饰器模式：增强已有的方案，动态将责任附加到对象上。例如：设备升级
（3）代理模式：不操作原对象本身，而操作其代理进行操作
//====模式场景
//中间转换参数模块间保持独立的时候----适配器模式。
//附着于多个组件上，批量动态赋予功能的时候---装饰器模式
//将代理对象与调用对象分离，不直接调用目标对象--代理模式

3、行为型：
//不同对象之间划分责任和算法的抽象化。
（1）命令模式：请求以命令的方式包裹在对象中，并传给调用对象。
（2）模板模式：基于编排，便于拓展
（3）观察者模式:模块间实时互通，当一个属性发生状态改变时，观察者会连续引发所有的相关状态改变。
（4）职责链模式：链式调用，职责独立，顺序执行。
